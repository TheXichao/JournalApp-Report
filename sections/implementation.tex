% implementation.tex
\chapter{Technical Implementation}
In this section of my report, I will highlight sections of my code with explanations. One thing I will also discuss is best practices and patterns that I have used in my project, such as defensive programming and modularity, etc.

\section{File Structure}
See the following of the tree structure of the project. This is created using the terminal tree command on a freshly cloned version of my repository so that only important files are shown:

\subsection{Backend}
\begin{verbatim}
├── ERdiagram.png
├── Email
│   ├── __init__.py
│   ├── apps.py
│   ├── cron.py
│   ├── sendEmail.py
│   └── tests.py
├── Entries
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── test.rest
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── JournalApp
│   ├── __init__.py
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   ├── views.py
│   └── wsgi.py
├── README.md
├── Users
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── serializers.py
│   ├── signals.py
│   ├── test.py
│   ├── test.rest
│   ├── urls.py
│   ├── utils.py
│   └── views.py
├── manage.py
├── package-lock.json
├── package.json
├── requirements.txt
└── secret.json
7 directories, 39 files
\end{verbatim}

\subsection{Frontend}
\begin{verbatim}
├── README.md
├── index.html
├── package-lock.json
├── package.json
├── public
│   └── vite.svg
├── src
│   ├── App.css
│   ├── App.tsx
│   ├── api
│   │   ├── axios.ts
│   │   ├── getAuthTokenFromCookie.ts
│   │   └── useApi.ts
│   ├── assets
│   │   └── react.svg
│   ├── components
│   │   └── layout
│   │       ├── NavBar.css
│   │       └── NavBar.tsx
│   ├── context
│   │   └── userContext.tsx
│   ├── hooks
│   │   ├── useAuth.ts
│   │   ├── useFetchData.tsx
│   │   ├── useUser.ts
│   │   └── useUserContext.ts
│   ├── index.css
│   ├── main.tsx
│   ├── pages
│   │   ├── HomePage.tsx
│   │   ├── ProfilePage.tsx
│   │   ├── entry
│   │   │   ├── CreateEntryPage.tsx
│   │   │   ├── JournalEntriesPage.tsx
│   │   │   └── sortEntries.ts
│   │   ├── login
│   │   │   ├── LoginPage.tsx
│   │   └── register
│   │       └── RegisterPage.tsx
│   └── vite-env.d.ts
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts
15 directories, 36 files
\end{verbatim}

\section{Skills}

\begin{table}[H]
  \centering
  \caption{Group A Model Skills Employed in Journal App Development}
  \begin{tabular}{|p{10cm}|p{4cm}|}
  \hline
  \textbf{Model Skill} & \textbf{Found in} \\
  \hline
  Complex data model in database (eg several interlinked tables) & Users/models.py and Entries/models.py from the Django project.\\
  \hline
  Hash tables, lists, stacks, queues, graphs, trees or structures of equivalent standard &  Retrieved (from Backend/local storage) entries are stored as an array. \\
  \hline
  Files(s) organised for direct access & Shown  above \\
  \hline
  Complex scientific/mathematical/robotics/control/business model & User session persistance as an example complex control model\\
  \hline
  Complex user-defined use of object-orientated programming (OOP) model, eg classes, inheritance, composition, polymorphism, interfaces & UML diagram in figure \ref{fig:UML} is fully implemented. \\
  \hline
  Complex client-server model & Flow of data between Frontend application and Backend via RESTful API  \\
  \hline
  \end{tabular}
  \end{table}


  \begin{table}[H]
    \centering
    \caption{Group A Algorithms Skills Employed}
    \begin{tabular}{|p{10cm}|p{4cm}|}
    \hline
    \textbf{Algorithm Skill} & \textbf{Found in} \\
    \hline
    Cross-table parameterised SQL & Used when retrieving journal and generating statistics about the journal\\
    \hline
    Aggregate SQL functions & Generate statistics about a user's Journal \\
    \hline
    List operations &  List of entries sorted and displayed in retrieveEntries page\\
    \hline
    Hashing & passwords are hashed and stored\\
    \hline
    Mergesort or similarly efficient sort &  designed and implemented Quicksort but later switched to Tim Sort\\
    \hline
    Dynamic generation of objects based on complex user-defined use of OOP model & MyUser, Jounral, Entries are all generated dynamically when the user is using the app\\
    \hline
    Server-side scripting using request and response objects and server-side extensions for a complex client-server model &  The core of my project\\
    \hline
    Calling parameterised Web service APIs and parsing JSON/XML to service a complex client-server model &  JSON data flows between my Frontend and Backend\\
    \hline
    \end{tabular}
    \end{table}

\section{Key Code Segments}
In this section, I will be highlighting key code segments from my project which I believe are important to understand the implementation of the project. To provide context, the source code from where these snippets are taken are also provided in the appendix.


\section{Data Structures}

\subsection{Data Models}
Data models are the backbone of my Backend server. In my design section (see figure \ref{fig:UML} for the UML diagram)I have already discussed the data models that I have used in my project. Here I will provide the implementation of the data models in Django.

\subsubsection{Modelling the User}
\begin{minted}{python3}
  from Django.db import models
  from Django.contrib.auth.models import AbstractBaseUser, UserManager, PermissionsMixin
  
  from .utils import clean_email, hash_password, validate_email, verify_password
  
  # Create your models here.
  
  
  def check_email_and_password(email: str, password: str | None) -> bool:
      if password is None:
          raise ValueError("Password is not valid")
      if not validate_email(email):
          raise ValueError("Email is not valid")
      return True
  
  
  class MyUserManager(UserManager):
      def create_user(self, email, password=None, **extra_fields):
          cleaned_email = clean_email(email)
          is_valid = check_email_and_password(cleaned_email, password)
          if is_valid:
              user = self.model(email=cleaned_email, **extra_fields)
              user.set_password(password)
              user.save()
  
      def create_superuser(self, email, password=None, **extra_fields):
          cleaned_email = clean_email(email)
          is_valid = check_email_and_password(cleaned_email, password)
          if is_valid:
              user = self.model(email=cleaned_email, **extra_fields)
              user.set_password(password)
              user.is_staff = True
              user.is_superuser = True
              user.save()
  
  
  class MyUser(AbstractBaseUser, PermissionsMixin):
      """A Users table used to store the data of my user a subclass implementing the default User model"""
  
      user_id = models.AutoField(primary_key=True)
      email = models.EmailField(unique=True)
      is_staff = models.BooleanField(default=False)
      creation_date = models.DateField(auto_now_add=True)
      first_name = models.CharField(max_length=30, null=True)
      last_name = models.CharField(max_length=30, null=True)
      email_prompt = models.BooleanField(default=False, null=True)
  
      # By convention, the manager attribute are named objects.
      objects = MyUserManager()
  
      USERNAME_FIELD = "email"
      REQUIRED_FIELDS = ["first_name", "last_name"]
  
      def get_full_name(self) -> str:
          return f"{self.first_name} {self.last_name}"
  
      def set_password(self, raw_password: str) -> None:
          self.password = hash_password(raw_password)
  
      def check_password(self, raw_password: str) -> bool:
          return verify_password(raw_password, self.password)
  
\end{minted}
Something to note here is that I have set the email field to be unique so there are no duplicate users; creation time is also auto-added.

To improve maintainability and readability, I have defined many helper functions in a separate file called utils.py. This is an example of decomposition and in my codebase, I try to follow the Single Responsibility Principal as much as possible. This makes the code more self-contained and also makes it easier to perform unit tests on the helper functions. The code included in the appendix will contain all the relevant codes relating to what I talk about in this section of the report.


\subsubsection{Modelling the Journal and Entries}
\begin{minted}{python3}
  from email.policy import default
  from Django.db import models, connection
  from Users.models import MyUser
  from Django.utils import timezone
  
  # sentiment analysis
  from google.cloud import language_v2
  
  
  # Create your models here.
  
  
  class Journal(models.Model):
      """A Journals table pointing to the owner used to link entries together with the user"""
  
      journal_id = models.AutoField(primary_key=True)
      user_id = models.OneToOneField(MyUser, on_delete=models.CASCADE)
      creation_date = models.DateField(auto_now_add=True)
  
      def get_all_entries(self):
          return self.entry_set.all()
  
      def get_most_active_month(self):
          with connection.cursor() as cursor:
              cursor.execute(
                  f"""
  SELECT
    EXTRACT(MONTH FROM "Entries_entry".creation_date) AS month,
    COUNT(*) AS entry_count
  FROM
    "Entries_entry"
  JOIN
    "Entries_journal" ON "Entries_journal".journal_id = "Entries_entry".journal_id_id
  WHERE
    "Entries_journal".journal_id = {self.journal_id}
  GROUP BY
    month
  ORDER BY
    entry_count DESC
  LIMIT 1;
                  """
              )
              row = cursor.fetchone()
              return row[0] if row else None
  
      def get_average_entries_per_week(self):
          with connection.cursor() as cursor:
              cursor.execute(
                  f"""
  SELECT
    AVG(entry_count)
  FROM (
    SELECT
      EXTRACT(YEAR FROM "Entries_entry".creation_date) AS year,
      EXTRACT(WEEK FROM "Entries_entry".creation_date) AS week,
      COUNT(*) AS entry_count
    FROM
      "Entries_entry"
    JOIN
      "Entries_journal" ON "Entries_journal".journal_id = "Entries_entry".journal_id_id
    WHERE
      "Entries_journal".journal_id = {self.journal_id}
    GROUP BY
      year, week
  )
  LIMIT 1; 
                  """
              )
              row = cursor.fetchone()
              return row[0] if row else None
  
      def get_total_word_count(self):
          with connection.cursor() as cursor:
              cursor.execute(
                  f"""
  SELECT
    SUM(
      LENGTH("Entries_entry".content) - LENGTH(REPLACE("Entries_entry".content, ' ', '')) + 1
    ) AS total_word_count
  FROM
    "Entries_entry"
  JOIN
    "Entries_journal" ON "Entries_journal".journal_id = "Entries_entry".journal_id_id
  WHERE
    "Entries_journal".journal_id = {self.journal_id};
                  """
              )
              row = cursor.fetchone()
              return row[0] if row else None
  
      def __str__(self):
          return f"{self.user_id}'s Journal"
  
  
  class Entry(models.Model):
      """An Entry table used to store the data of t journal entry and also tell us which journal it belongs to"""
  
      entry_id = models.AutoField(primary_key=True)
      journal_id = models.ForeignKey("Journal", on_delete=models.CASCADE)
      creation_date = models.DateField(default=timezone.now, editable=True)
      title = models.CharField(max_length=50, default="Untitled")
      content = models.TextField()
      sentiment = models.FloatField(default=None, blank=True, null=True)
  
      def __str__(self) -> str:
          return f"Entry {self.entry_id} from {self.journal_id}"
  
      # analyse data and return sentiment score range from -1 to 1 by calling google cloud api
      def analyse_sentiment(self) -> float:
          client = language_v2.LanguageServiceClient()
          document = language_v2.Document(
              content=self.content, type_=language_v2.Document.Type.PLAIN_TEXT
          )
          response = client.analyze_sentiment(request={"document": document})
          return response.document_sentiment.score
\end{minted}

Journal and MyUser have a one-to-one Aggregate relationship, I figured it doesn't make sense for a Journal to exist, so I have specified an on\_delete option to resolve this integrity error if a user is deleted. CASCADE is just an option that will delete the journal if the user is deleted. This is another defensive design. The same relationship exists between Entries and Journal as Journals are composed of Entries.


\subsection{Generated diagram}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{SourceCode/Backend/ERdiagram.png}
  \caption{Here is a diagram generated based on my implemented Django Models using the Django-extensions library}
  \label{fig:ERdiagram}
\end{figure}

\subsection{Typescript Interfaces}
To model JSON response provided by the Backend, I have created interfaces in Typescript. This is useful as it allows me to have type-checking in my codebase. This is especially useful when I am making API calls to the Backend and I want to ensure that the data I am receiving correctly matches the data I am expecting. Here are a few examples of interfaces that I have created in my Frontend more can be found in the source code:

\begin{minted}{typescript}
  export interface Entry {
  entry_id: number;
  title: string;
  content: string;
  creation_date: string;
}
\end{minted}
\begin{minted}{typescript}
  interface registerRequestData {
  email: string;
  password: string;
  first_name: string;
  last_name: string;
}
\end{minted}

\begin{minted}{typescript}
export interface Statistics {
  most_active_month: string;
  average_entries_per_week: number;
  total_word_count: number;
}
\end{minted}



\section{Algorithms}

\subsection{Applying Tim Sort on Entries with specified Key}
I have fully explained how the code works in detail in the comments of the code. How as a summary Tim Sort works by applying insertion on chunks of the array, and then these smaller chunks are merged together. Here is the implementation:
\begin{minted}{python3}
  import { Entry} from "./JournalEntriesPage";


  export function sortEntriesByDate(entries: Entry[] | null, sortOrder: string): Entry[] {
    // defensive programming
    if (!entries) {
      return Array<Entry>();
    }
    // zipping the entries with their creation date
    const zippedEntries = entries.map((entry) => {
      return [entry, new Date(entry.creation_date).getTime()] as [Entry, number];
    })
  
    Tim Sort(zippedEntries);
  
    // returns the sorted entries in unzipped format
    if (sortOrder === "desc") {
      return zippedEntries.map((zippedEntry) => zippedEntry[0]).reverse();
    }
    return zippedEntries.map((zippedEntry) => zippedEntry[0]);
  }
  
  
  function insertionSort<Key>(
    arr: Array<[Entry, Key]>,
    startIndex: number,
    endIndex: number,
  ) {
  
    // iterate the segment of the array from startIndex to endIndex
    for (let i = startIndex + 1; i < endIndex; i++) {
      // increment the currently searching index i with each pass, and use j as a temprary index to compare the current element with all previous elements
      let j = i;
  
      while (j > startIndex && arr[j - 1][1] > arr[j][1]) {
  
        // compare the current element with every single previous element and keep swapping until it is in the right position
        swap(arr, j, j - 1);
        j--;
      }
    }
  }
  
  function swap<T>(arr: Array<[Entry, T]>, i: number, j: number) {
    const temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
  
  
  function merge<Key>(arr: Array<[Entry, Key]>, left: number, mid: number, right: number) {
    //The two different segments sorted by insertion sort need to be merged, the left segment is from left to mid, and the right segment is from mid to right
    const leftArr = arr.slice(left, mid);
    const rightArr = arr.slice(mid, right);
  
  
    // i is the index of the left segment, j is the index of the right segment, and k is the index of the merged segment
    let i = 0;
    let j = 0;
    let k = left;
    
    // going through all the elements of the left and right segments and compare them, and merge them in the right order
    while (i < leftArr.length && j < rightArr.length) {
      
      // basically means if the left element is smaller than the right element, then put the left element in the merged segment, otherwise put the right element in the merged segment in that sequence
      if (leftArr[i][1] <= rightArr[j][1]) {
        arr[k] = leftArr[i];
        i++;
      } else {
        arr[k] = rightArr[j];
        j++;
      }
      k++;
    }
  
    // if there are any remaining elements in the left or right segment, then put them in the merged segment
    while (i < leftArr.length) {
      arr[k] = leftArr[i];
      i++;
      k++;
    }
  
    while (j < rightArr.length) {
      arr[k] = rightArr[j];
      j++;
      k++;
    }
  }
  
  function Tim Sort<Key>(zippedEntries: Array<[Entry, Key]>){
    // run means the size of the segments that will be sorted by insertion sort
    const RUN = 16;
    const n = zippedEntries.length;
  
    // use insertion sort on all the individual runs with the size of RUN
    for (let i = 0; i < n; i += RUN) {
      // math.min is used so that the sorting does not go out of bounds
      insertionSort(zippedEntries, i, Math.min(i + RUN, n));
    }
  
  
    // merge all the the sorted segments
    for (let size = RUN; size < n; size = 2 * size) {
      for (let left = 0; left < n; left += 2 * size) {
        const mid = left + size;
        const right = Math.min(left + 2 * size, n);
        merge(zippedEntries, left, mid, right);
      }
    }
  }
  
\end{minted}

The code I have written here is designed to be reusable as I have created the sorting functions such that it sorts based on a zipped entry.

sortEntriesByDate is one of the functions that utilise the Tim Sort module, It takes in an array of entries, then creates a new array with a tuple of the entry and the creation date. This is then passed to the Tim Sort function which sorts the array based on the second index of the array (the key). The sorted array is then unzipped and returned. 

In the future, the sorting modules can be used with any key by simply zipping the array with a different key and passing it to the Tim Sort function. 


\subsection{Implementation of the SQL Queries}
To provide context, the following are the SQL queries that are implemented in the Django ORM as methods of the Journal model. This allows me to leverage powerful features of Python/Django enabling me to make more dynamic queries with ease. For example, I can access the journal id of the current instance of the model using self.journal\_id, which can then be used directly in the query through string interpolation. In action, when a user accesses the API endpoint to get their journal statistics, self refers to the user making the request. Therefore, the query will return the statistics of the journal that the user who just made that request. Having these as methods is also a good practice as it allows for better modularity and readability.


\subsubsection{Most Active Month (see test \ref{fig:most_active_month})}
\begin{minted}{SQL}
SELECT
  EXTRACT(MONTH FROM "Entries_entry".creation_date) AS month,
  COUNT(*) AS entry_count
FROM
  "Entries_entry"
JOIN
  "Entries_journal" ON "Entries_journal".journal_id = "Entries_entry".journal_id_id
WHERE
  "Entries_journal".journal_id = {self.journal_id}
GROUP BY
  month
ORDER BY
  entry_count DESC
LIMIT 1;
\end{minted}

AS is used to alias the column names which makes the query more readable and efficient to write.

\subsubsection{Average Entry Count Per Week (see test \ref{fig:average_entry_per_week})}
\begin{minted}{SQL}
  SELECT
    AVG(entry_count)
  FROM (
    SELECT
      EXTRACT(YEAR FROM "Entries_entry".creation_date) AS year,
      EXTRACT(WEEK FROM "Entries_entry".creation_date) AS week,
      COUNT(*) AS entry_count
    FROM
      "Entries_entry"
    JOIN
      "Entries_journal" ON "Entries_journal".journal_id = "Entries_entry".journal_id_id
    WHERE
      "Entries_journal".journal_id = {self.journal_id}
    GROUP BY
      year, week
  )
\end{minted}

\subsubsection{Total Word Count (see test \ref{fig:total_word_count}}
\begin{minted}{SQL}
SELECT
    SUM(
      LENGTH("Entries_entry".content) - LENGTH(REPLACE("Entries_entry".content, ' ', '')) + 1
    ) AS total_word_count
  FROM
    "Entries_entry"
  JOIN
    "Entries_journal" ON "Entries_journal".journal_id = "Entries_entry".journal_id_id
  WHERE
    "Entries_journal".journal_id = {self.journal_id};
\end{minted}

\section{Modularity}
Modularity is shown throughout my codebase and I try splitting code into modules when it makes sense. A couple of examples I thought were worth mentioning are the hooks I have created in my Frontend to make calls to the Backend API and also the modules I created to enable persistent login in the Frontend using context. 

\subsection{API call functions}
Here I will include the code for the hooks I have created to make API calls to the Backend. This module is repeatedly reused throughout the Frontend to make calls to the Backend. For demonstration sake, I will be only including one example of my useApi hook in action.

\subsubsection{useApi.ts}
\begin{minted}{typescript}
import { useState,  useCallback } from "react";
import  { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";
import { myApiCall } from "./axios";

// generic interface for the hook's return type
interface ApiHookState<T> {
  isLoading: boolean;
  error: AxiosError | null; 
  data: T | null;
  fetchData: () => Promise<void>;
}

export default function useApi<T>(
  config: AxiosRequestConfig,
): ApiHookState<T> {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [data, setData] = useState<T | null>(null);

  const fetchData = useCallback(async () => {
        setIsLoading(true);
        try {
          const response: AxiosResponse<T> = await myApiCall(config);
          setData(response.data);
        } catch (error: any) {
          setError(error);
        } finally {
          setIsLoading(false);
        }
      }, [config]);
      return { isLoading, error, data, fetchData };
    }
\end{minted}
I have created the useApi hook because whenever I make a call to the Backend, I want to be able to retrieve information about whether the call is loading, if there is an error, and the data that is returned. These information are valuable as they can be used to conditionally render different information to the user. 

This piece of code is built on top of the Axios library which is a promised\footnote{Promise is an asynchronous operation that can either succeed or fail. }  based library for HTTP requests. A promise exists in one of three states: pending, fulfilled, or rejected. See my implementation to see how to extract additional information from my call.

To implement this feature, I have used try-catch block to handle the promise. If the promise is fulfilled, the data is stored in the data state, if the promise is rejected, the error is stored in the error state. Finally, the isLoading state is set to false to indicate that the fetch is complete. This is also an example of defensive programming.

A generic interface is used to define the return type of the hook. This is useful since it increases the reusability of the module. I can simply pass in an appropriate interface when I call the hook (like the ones I listed earlier).

There are many rules when using hooks, one of those is that I cannot define a hook inside a function. This is why I have made use of the useCallback function so that I can trigger the fetchData function whenever I need to make an API call. The fetchData function acts as my trigger and they are typically used when users press a button or when the page loads. An example is shown in the RegisterPage.tsx below.

\subsubsection{from axios.ts}
\begin{minted}{typescript}
...
export const myApiCall: AxiosInstance = axios.create({
    baseURL: "http://127.0.0.1:8000/", 
    timeout: 5000, // time before the request times out in milliseconds
    headers: {
        "Content-Type": "application/json", // I use json as the default content type 
        
    },
});
\end{minted}

\subsubsection{RegisterPage.tsx}
\begin{minted}{typescript}
import { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import useAuth from "../../hooks/useAuth";
import useApi from "../../api/useApi";
import { User } from "../../hooks/useUser";

interface registerRequestData {
  email: string;
  password: string;
  first_name: string;
  last_name: string;
}

export default function RegisterPage(): JSX.Element {
  // my states
  const [registerRequestData, setregisterRequestData] =
    useState<registerRequestData>({} as registerRequestData);
  const navigate = useNavigate();
  const { login } = useAuth();

  const { isLoading, error, data, fetchData } = useApi<User>({
    url: "/user/register/",
    method: "post",
    data: {
      email: registerRequestData.email,
      password: registerRequestData.password,
      first_name: registerRequestData.first_name,
      last_name: registerRequestData.last_name,
    },
  });

  useEffect(() => {
    if (data) {
      // redirect to profile page
      login(data);
      navigate("/profile");
    }
  }, [data]);
  const onRegisterFunc = () => {
    console.log("Registering...");
    fetchData(); // triggers myApiCall
  };
  return (
    <div>
      <input
        placeholder="email"
        value={registerRequestData.email}
        onChange={(e) =>
          setregisterRequestData({
            ...registerRequestData,
            email: e.target.value,
          })
        }
      />
      <input
        type="password"
        placeholder="password"
        value={registerRequestData.password}
        onChange={(e) =>
          setregisterRequestData({
            ...registerRequestData,
            password: e.target.value,
          })
        }
      />
      <input
        placeholder="first name"
        value={registerRequestData.first_name}
        onChange={(e) =>
          setregisterRequestData({
            ...registerRequestData,
            first_name: e.target.value,
          })
        }
      />
      <input
        placeholder="last name"
        value={registerRequestData.last_name}
        onChange={(e) =>
          setregisterRequestData({
            ...registerRequestData,
            last_name: e.target.value,
          })
        }
      />
      {isLoading && <div>Loading...</div>}
      {error && <div>{error.message}</div>}
      {error && <div>{JSON.stringify(error.response?.data)}</div>}
      {data && (
        <div>
          Registered successfully
          <div>Welcome {data.first_name}</div>
        </div>
      )}

      <br />

      <input
        disabled={isLoading}
        type="button"
        value="Register"
        onClick={onRegisterFunc}
      />
    </div>
  );
}
\end{minted}
Before the button is clicked I have made use of the useState hook to store the user's input, and as the user types in the input field, the state is updated.

In this example by using my useApi hook, as the button is clicked (see line 102), onRegisterFunc is called which triggers the fetchData function, which activates my logic of the useApi call, submitting all the information stored in my states to my Backend. My useApi function provides live feedback about the state of the fetch as it happens, and that information can help me dynamically display information to the user.

In line 99, I have set disabled to isLoading so that the button is disabled when the fetch is loading, which is a defensive programming technique to prevent multiple clicks on the button. 

In addition, see line 86 for a couple of examples of how I conditionally render different information based on the state of the fetch. Conditional rendering is another technique I employed throughout my Frontend to provide a better user experience as well as to defensively program my application.

\subsection{Persistent Login Session}
To enable persistent login sessions in my React app, the browser's local storage as well as context is used. Context is used so that the user's information can be stored and accessed throughout the application, avoiding the need for prop drilling\footnotetext{In react information is passed through components from parent to child, Prop Drilling is when a certain piece of information is passed through many components. This is bad practice as it clogs up the code making it difficult to maintain.}. 




\subsubsection{useUser.ts}
\begin{minted}{typescript}
import Cookies from "universal-cookie";
import useUserContext from "./useUserContext";

export interface User {
    user_id: number;
    email: string;
    first_name: string;
    last_name: string;
    authToken?: string;
    email_prompt: boolean;
  }
export default function useUser() {
    const { updateUser } = useUserContext();

    const cookies = new Cookies();

    const addUser = (user: User) => {
        cookies.set("user", user, { path: "/",
        secure: true,
        sameSite: "strict"

    });
        updateUser(user);
        console.log("User added");
    }

    const removeUser = () => {
        cookies.remove("user");
        updateUser(null);
        console.log("User removed");
    }
    const getUser = (): User | undefined  => {
        return cookies.get("user");
    }

    return {
        addUser,
        removeUser,
        getUser
    }
}
\end{minted}
useUser is a hook I have defined that governs the storage and retrieval of user information. It is used to store the user's information in the user's browser in the form of cookies\footnotetext{I have chosen cookies instead of local storage for security reasons, see defensive programming section.}, and also to retrieve the user's information storage. This is useful as it allows me to persist even if the user closes the tab or refreshes. Cookie configuration is also set to be secure and sameSite to strict to prevent CSRF attacks.

See lines 29 and 23, the context is also updated at the same time the cookie is updated. This is to ensure that the user's information is accessible throughout the application.


\subsubsection{userContext.tsx}
\begin{minted}{typescript}
import Cookies from "universal-cookie";
import { User } from "../hooks/useUser";
import React, { createContext, useState, ReactNode, useEffect } from "react";

export interface UserContextType {
  user: User | null;
  updateUser: (user: User | null) => void;
}

export const UserContext = createContext<UserContextType | undefined>(
  undefined
);

export const UserProvider: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const cookies = new Cookies();
  const [user, setUser] = useState<User | null>(() => {
    // prevent my user from being lost on refresh
    const savedUser = cookies.get("user");
    if (savedUser) {
      return savedUser;
    }
  });

  const updateUser = (newUser: User | null) => {
    setUser(newUser);
    console.log("update user for context: ", newUser, user);
  };

  useEffect(() => {
    if (user) console.log("user context: ", user);
  }, [user]);

  return (
    <UserContext.Provider value={{ user, updateUser }}>
      {children}
    </UserContext.Provider>
  );
};
\end{minted}


\subsubsection{useUserContext.ts}
\begin{minted}{typescript}
import { useContext} from "react";
import { UserContext, UserContextType  } from "../context/userContext";

export default function useUserContext() {
    const context = useContext(UserContext) as UserContextType;

    if (context === undefined) {
        throw new Error("useUser must be used within a UserProvider");
    }

    return context;

}
\end{minted}

As you can see here in my provider I have user and updateUser as the context value, these are the two functions that are used to retrieve and update the user's information. I have created a useUserContext hook to access the context to make the code clearer and more modular.


\subsubsection{main.tsx}
\begin{minted}{typescript}
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.tsx";
import "./index.css";
import { UserProvider } from "./context/userContext.tsx";
// import { QueryClient, QueryClientProvider } from "react-query";
import { BrowserRouter } from "react-router-dom";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <UserProvider>
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </UserProvider>
  </React.StrictMode>
);
\end{minted}
This is the entry point of my application. I have wrapped my entire app components and routes in the UserProvider so that the user's information can be accessed throughout the entire application.

\subsubsection{useAuth.ts}
\begin{minted}{typescript}
import { User } from "./useUser";
import useUser from "./useUser";

export default function useAuth() {
    const { getUser, addUser, removeUser } = useUser();

    const login = (user: User) => {
        addUser(user);
    }

    const logout = () => {
        removeUser();
    }

    const isAuthenticated = () => {
        return getUser() !== undefined;
    }

    return {
        login,
        logout,
        isAuthenticated
    }}
\end{minted}
useAuth is used to login and logout of the user. These are created to make the code more modular as it uses the useUser to perform certain actions on the user's information. This is also an example of the Single Responsibility Principal as the useAuth hook is only responsible for authentication and nothing else.






\subsection{Virtual Environment}
Virtual environment is used to manage the dependencies of the project. This is useful as it allows me to keep the dependencies of the project separate from the dependencies of the system. I have also included the requirements for both the Django and React app in the root of the projects. This is also useful for deployment as it allows me to easily deploy the project on a server without having to worry about the dependencies.

\section{Defensive Programming / Robustness}
In this section, I will be discussing the defensive programming techniques and preventions I have implemented in my project to ensure that the application is robust and secure.

\subsection{Sanity checking}
\begin{minted}{python3}
import re
def validate_email(email: str) -> bool:
  return re.match(r"[^@]+@[^@]+\.[^@]+", email) is not None


def clean_email(email: str) -> str:
cleaned_email = re.search(r"[^@]+@[^@]+\.[^@]+", email)
if cleaned_email is not None:
    parsed_email =  cleaned_email.group(0)
    return parsed_email.lower().strip()
else:
    return ""
\end{minted}
These functions are used in the User model to validate and clean the email before it is stored in the database. The regex ensures the email format is in the form of email in the correct form. This simple regex basically ensures that the email is in the form of a@b.c where a, b, c are characters that are not @. This is a simple form of input validation to ensure that the email is in the correct format before it is stored in the database.

For cleaning the data I extract the text matching that regex then convert it into lowercase and strip any leading or trailing whitespace. This is to ensure that the email is stored in a consistent format in the database.

\subsection{Password Hashing}
\begin{minted}{python3}
import hashlib
import os


def hash_password(password: str) -> str:
    salt = os.urandom(16)
    salted_password = salt + password.encode("utf-8")

    sha256_hash = hashlib.sha256()
    sha256_hash.update(salted_password)
    hashed_password = sha256_hash.hexdigest()

    return f"{salt.hex()}:{hashed_password}"


def verify_password(password: str, hashed_password: str) -> bool:
    salt, stored_hash = hashed_password.split(":")

    salted_password = bytes.fromhex(salt) + password.encode("utf-8")
    sha256_hash = hashlib.sha256()
    sha256_hash.update(salted_password)
    provided_hash = sha256_hash.hexdigest()

    return provided_hash == stored_hash

\end{minted}
A salt is basically a random string that is added to the password before it's hashed and it prevents the same password from having the same hash value, hence reducing the risk of a dictionary attack or rainbow table attack. In my database I store the salt and the hashed password in the format salt(in hex):hashed\_password. This is to ensure that the salt is stored along with the password so that it can be used to verify the password when the user logs in.

Verify password is used to verify the password when the user logs in. It takes the input password, hashes it with the stored salt, and sees if the hashes match. If they match then the password is correct, if not then the password is incorrect.

\subsection{SQL Injection}
SQL injection is protected in my codebase as I have used Django's ORM to make queries to the database. Django's ORM automatically escapes the input to prevent SQL injection. This prevents malicious users from injecting SQL code into the database. 

\subsection{Cross Site Request Forgery (CSRF)}
To prevent CSRF attacks, Django has a built-in middleware that checks the CSRF token in the request. This is enabled by default in Django and is used to prevent CSRF attacks. This is a good practice as it prevents malicious users from making requests on behalf of the user.

\subsection{Cookies vs Local Storage}
Sensitive information like user data and authentication tokens are stored in cookies instead of local storage. This is because cookies are more secure than local storage, because Local storage is vulnerable to XSS attacks, while cookies are not. 

For retrieved journal entries, however, I have used local storage as it is not sensitive information. Each website has access to 5MB of data that can be stored in local storage, so caching the journal entries in local storage is a good practice as it reduces the number of requests made to the server.

\subsection{Rate Limiting}
\begin{minted}{python3}
  # from JournalApp/settings.py
  REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.BasicAuthentication",
        "rest_framework.authentication.SessionAuthentication",
    ],
    "DEFAULT_THROTTLE_CLASSES": [
        "rest_framework.throttling.AnonRateThrottle",
        "rest_framework.throttling.UserRateThrottle",
    ],
    "DEFAULT_THROTTLE_RATES": {
        "anon": "8/minute",
        "user": "30/minute",
    },
}
\end{minted}
With Django Rest Framework, I can configure the rate limit of the API to prevent DoS attacks. In this example, I have set the rate limit to 8 requests per minute for anonymous users and 30 requests per minute for authenticated users. 

\subsection{secret key management}
I have stored my sensitive details like logins or keys in a secret.json file, which is included in my git ignore file. This is to prevent the secret key from being exposed in the repository. 

\section{Error Handling}
Error handling is used throughout my application, here's a typical example from Users/views.py:

\begin{minted}{python3}
  @api_view(["POST"])
  def login_view(request) -> Response:
      try:
          user = MyUser.objects.get(email=request.data["email"])
          if user.check_password(request.data["password"]):
              token, created = Token.objects.get_or_create(user=user)
              user_data = MyUserSerializer(user).data
              user_data["token"] = token.key
              response_data = {
                  "user_id": user.user_id,
                  "email": user.email,
                  "first_name": user.first_name,
                  "last_name": user.last_name,
                  "authToken": token.key,
              }
              return Response(response_data, status=status.HTTP_200_OK)
          else:
              return Response(
                  {"error": "Invalid password"}, status=status.HTTP_400_BAD_REQUEST
              )
  
      except MyUser.DoesNotExist:
          return Response(
              {"error": "User does not exist"}, status=status.HTTP_404_NOT_FOUND
          )
\end{minted}


