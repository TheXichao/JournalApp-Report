% implementation.tex
\chapter{Technical Implementation}
In this section of my report, I will highlight section of my code with explanations. One thing I will also discuss is best practices and patterns that I have used in my project, such as defensive programming and modularity, etc.

\section{File Structure}
See the following of the tree structure of the project. This is created using the terminal tree command on a freshly cloned version of my repository so that only important files are shown:

\subsection{Backend}
\begin{verbatim}
├── ERdiagram.png
├── Email
│   ├── __init__.py
│   ├── apps.py
│   ├── cron.py
│   ├── sendEmail.py
│   └── tests.py
├── Entries
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── test.rest
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── JournalApp
│   ├── __init__.py
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   ├── views.py
│   └── wsgi.py
├── README.md
├── Users
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── serializers.py
│   ├── signals.py
│   ├── test.py
│   ├── test.rest
│   ├── urls.py
│   ├── utils.py
│   └── views.py
├── manage.py
├── package-lock.json
├── package.json
├── requirements.txt
└── secret.json
7 directories, 39 files
\end{verbatim}

\subsection{Frontend}
\begin{verbatim}
├── README.md
├── index.html
├── package-lock.json
├── package.json
├── public
│   └── vite.svg
├── src
│   ├── App.css
│   ├── App.tsx
│   ├── api
│   │   ├── axios.ts
│   │   ├── getAuthTokenFromCookie.ts
│   │   └── useApi.ts
│   ├── assets
│   │   └── react.svg
│   ├── components
│   │   └── layout
│   │       ├── NavBar.css
│   │       └── NavBar.tsx
│   ├── context
│   │   └── userContext.tsx
│   ├── hooks
│   │   ├── useAuth.ts
│   │   ├── useFetchData.tsx
│   │   ├── useUser.ts
│   │   └── useUserContext.ts
│   ├── index.css
│   ├── main.tsx
│   ├── pages
│   │   ├── HomePage.tsx
│   │   ├── ProfilePage.tsx
│   │   ├── entry
│   │   │   ├── CreateEntryPage.tsx
│   │   │   ├── JournalEntriesPage.tsx
│   │   │   └── sortEntries.ts
│   │   ├── login
│   │   │   ├── LoginPage.tsx
│   │   │   └── useLoginAPI.tsx
│   │   └── register
│   │       └── RegisterPage.tsx
│   └── vite-env.d.ts
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts
15 directories, 36 files
\end{verbatim}

\section{Key Code Segments}
Highlight essential code segments. 
\subsection{Typing}


\section{Data Structures}
Explain the implementation of data structures.

\section{Algorithms}
Detail the implementation of algorithms.

\subsection{Implementation of the SQL Queries}
To provide context, the following are the SQL queries that are implemented in the Django ORM as methods of the Journal model. This allow me to leverage powerful features of Python/Django enabling me to make more dynamic queries with ease. For example I can access the journal id of the current instance of the model using self.journal\_id, which can then be used directly in the query through string interpolation. In action, when a user accesses the API endpoint to get their journal statistics, self refers to user making the request. Therefore, the query will return the statistics of the journal that the user who just made that request. Having these as methods is also a good practice as it allows for better modularity and readability.


\subsubsection{Most Active Month}
\begin{lstlisting}[language=SQL]
SELECT
  EXTRACT(MONTH FROM "Entries_entry".creation_date) AS month,
  COUNT(*) AS entry_count
FROM
  "Entries_entry"
JOIN
  "Entries_journal" ON "Entries_journal".journal_id = "Entries_entry".journal_id_id
WHERE
  "Entries_journal".journal_id = {self.journal_id}
GROUP BY
  month
ORDER BY
  entry_count DESC
LIMIT 1;
\end{lstlisting}

AS is used to alias the column names which makes the query more readable and efficient to write.

\subsubsection{Average Entry Count Per Week}
\begin{lstlisting}[language=SQL]
  SELECT
    AVG(entry_count)
  FROM (
    SELECT
      EXTRACT(YEAR FROM "Entries_entry".creation_date) AS year,
      EXTRACT(WEEK FROM "Entries_entry".creation_date) AS week,
      COUNT(*) AS entry_count
    FROM
      "Entries_entry"
    JOIN
      "Entries_journal" ON "Entries_journal".journal_id = "Entries_entry".journal_id_id
    WHERE
      "Entries_journal".journal_id = {self.journal_id}
    GROUP BY
      year, week
  )
\end{lstlisting}

\subsubsection{Total Word Count}
\begin{lstlisting}[language=SQL]
SELECT
    SUM(
      LENGTH("Entries_entry".content) - LENGTH(REPLACE("Entries_entry".content, ' ', '')) + 1
    ) AS total_word_count
  FROM
    "Entries_entry"
  JOIN
    "Entries_journal" ON "Entries_journal".journal_id = "Entries_entry".journal_id_id
  WHERE
    "Entries_journal".journal_id = {self.journal_id};
\end{lstlisting}

\section{Modularity}


\subsection{Virtual Environment}
Discuss the modularity of the project.

\section{Defensive Programming / Robustness}
Explain the measures taken for defensive programming and robustness.


\subsubsection{Cross Site Request Forgery (CSRF)}

\subsection{Server Based Authentication}
\subsubsection{Cross-Site Scripting (XSS)}


\section{Patterns}
\subsection{Single Responsibility Principal}


\section{Credential Management}